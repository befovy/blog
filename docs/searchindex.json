{"categories":[],"posts":[{"content":"周末时间用 Go 语言完成了 Flutter 多版本管理工具的初个版本 fvm v0.1.0。我必须承认，这个版本完全是在造轮子，而且还是和 leoafarias fvm 一模一样。\n为什么造轮子 简单说就是有需求：在开发 fijkplayer （一个 Flutter 的媒体播放器）的过程中，我逐渐从开始只有 Android、iOS 的移动端版本，发展到 Flutter 桌面版本。在 fijkplayer 桌面版的开发中，我用的是 go-flutter 为 Flutter 提供桌面支持，go-flutter 默认用的是 flutter beta 版本，而移动端 fijkplayer 用的是 Flutter stable 版本。\n最开始每次切换我都很痛苦，flutter 切换 channel 需要下载大量内容，channel 切换完成后再跑 flutter doctor 有需要大量的下载，而且还都是国外服务器，下载非常慢。\n后来我发现了 leoafarias fvm，但这个工具安装第一次没成功，其实我对 dart native 也不太懂，确实没搞定安装问题。另外 dart native 是不是真的二进制我也没有研究，要是还需要 dart 才能跑起来（就像运行 jar 需要 jvm 一样），其实我是不喜欢桌面端这种带有运行时的东西的。我就需要一个小工具而已。\n所以干嘛不自己造（chao）一个呢？\n刚好做 go-flutter 开发的时候对其自带工具 hover 进行过修改 并合并到了主分支。 hover 也是一个命令行小工具，而且可以直接通过 go get 安装， hover 使用库 spf13/cobra 实现命令行子命令以及参数解析等 “样板代码”，工程结构很简洁、清晰。\n另一方面，我虽然很早就学习过 go 语言，并且也在很多小项目（对，主要是我上学时完成的大作业）中用过 go。用的挺多但是不够系统化，写的代码还仅仅是个 demo。最近打算让自己的 go 语言水平再上一个台阶，一个行动是加入了 GCTT - go 中文翻译组 ，翻译一些国外大牛的优质文章，同时我打算认真搞一个 go 项目开源出来。 但是从啥搞起呢， 就从做一个 fvm 开始吧。\n是的， 第一个版本 v0.1.0 完全实现了 leoafarias fvm 中的所有逻辑，是个不折不扣的轮子工程。但是后面的版本就从 leoafarias fvm 脱离了，我要开发中国特色的 fvm。\ncobra 创建 go 命令行工具 spf13/cobra 是一个能够帮我们快速创建 go 命令行工具的 go 库，通过提供了一个生成 \u0026ldquo;样本代码\u0026rdquo; 的 go 工具。Go 世界中鼎鼎大名的 Docker、Kubernetes、Hugo 等都用了 cobra 来构建命令。\n首先，安装 cobra 工具：\n› go get -u github.com/spf13/cobra/cobra 使用 cobra 创建项目 fvm ，并使用 github.com/befovy/fvm 作为包名：\n› cobra init fvm --pkg-name github.com/befovy/fvm 使用 cobra add 需要的子命令：\n› cobra add list › cobra add install › cobra add remove › cobra add flutter › cobra add use › cobra add config 完成这些步骤后我们有了这些文件：\n› tree ./ ./ ├── LICENSE ├── cmd │ ├── config.go │ ├── flutter.go │ ├── install.go │ ├── list.go │ ├── remove.go │ ├── root.go │ └── use.go └── main.go 然后我们初始化 go modules ，下载依赖并编译fvm 。\n› go mod init github.com/befovy/fvm › go mod tidy › go build 编译好的 fvm 出现了，运行一下看看发生什么。\n› ./fvm A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: fvm [command] Available Commands: config A brief description of your command flutter A brief description of your command help Help about any command install A brief description of your command list A brief description of your command remove A brief description of your command use A brief description of your command Flags: --config string config file (default is $HOME/.fvm.yaml) -h, --help help for fvm -t, --toggle Help message for toggle Use \u0026#34;fvm [command] --help\u0026#34; for more information about a command. cobra 已经构建好了 fvm 的雏形，并且添加好了子命令。接下来就该实现 fvm 的具体逻辑了。\nfvm 的功能实现 fvm 作为一个 sdk 版本管理工具，让用户能够同时在本地安装并缓存多个 Flutter 版本，并且能够快速在各个版本间切换使用。\n其核心逻辑就是在本地文件夹中缓存多个 Flutter 版本，并为项目创建指定 Flutter 版本的软链接。或者在全局环境创建指定版本的 Flutter 软链接。\n内部主要功能实现都依赖于 go 语言标准库中的 os/exec 包。通过 os/exec 可以创建子进程执行命令，并管理子进程的输入输出。\nfvm 的各个子命令，基本就是查找一些文件、文件夹，执行以下 git 命令并对其输出进行解析。\n具体的实现都在 代码里，这里不啰嗦了。\n实现中要注意检查各种可能的错误，输出错误提示给用户。如果错误影响业务逻辑继续执行，就主动退出程序。\n在 fvm v0.1.0 版本中，这方便处理还不够细致。但仅这些我就感觉到了 go 中烦人的 error。后续还要进行重构，用更优雅的代码对 error 进行处理。\n收获总结 通过实现一个 fvm 我得到了什么呢？\n  我给自己写了个工具，方便我切换 Fluter 版本。\n  fvm 才只是一个开始，其难度还比不上我以前完成的大作业。但是 fvm 开源了、发布了。恰好刚翻译一片文章，Go Modules : v2 及更高版本， 通过持续更新维护 fvm 我也能实践 Go Modules 背后的理念。\n  这个版本的 fvm 还太简单，用到的知识很少。但是如果以后遇到什么相关新的知识、牛逼idel，我也能在 fvm 中快速试水。毕竟每次用 hello world 试水太乏味了。\n  最后，希望 fvm 能够得到大家的关注，并且收到反馈。\n","id":0,"section":"posts","summary":"周末时间用 Go 语言完成了 Flutter 多版本管理工具的初个版本 fvm v0.1.0。我必须承认，这个版本完全是在造轮子，而且还是和 leoafarias fvm 一模一样。 为什么造轮子 简单","tags":["Flutter","golang"],"title":"Go 打造 Flutter 多版本管理工具：fvm","uri":"https://blog.befovy.com/2019/12/fvm-using-go/","year":"2019"},{"content":"本文是一篇翻译文章: https://blog.golang.org/v2-go-modules 原文作者：Jean de Klerk 和 Tyler Bui-Palsu 译者：befovy 校对：polaris1119 译文由 GCTT 原创编译，Go语言中文网 荣誉推出\n 简介 本文是 Go modules 系统的第四部分\n Part 1: 使用 Go Modules 译文 Part 2: 迁移到 Go Modules 译文 Part 3: 发布 Go Modules 译文 Part 4: Go Modules : v2 及更高版本 (本文)   随着成功的项目逐渐成熟以及新需求的加入，早期的功能和设计决策可能不再适用。 开发者们可能希望通过删除废弃使用的功能、重命名类型或将复杂的程序拆分为可管理的小块来融入他们的经验教训。这种类型的变更要求下游用户进行更改才能将其代码迁移到新的 API，因此在没有认真考虑收益成本比重的情况下，不应进行这种变更。\n对于还在早期开发阶段的项目（主版本号是 v0），用户会期望偶尔的重大变更。对于声称已经稳定的项目（主版本是 v1 或者更高版本），必须在新的主版本进行重大变更。这篇文章探讨了主版本语义、如何创建并发布新的主版本以及如何维护一个 Go Modules 的多个主版本。\n主版本和模块路径 模块在 Go 中确定了一个重要的原则，即 “导入兼容性规则”\n 如果旧包和新包的导入路径相同，新包必须向后兼容旧的包\n 根据这条原则，一个软件包新的主版本没有向后兼容以前的版本。这意味着这个软件包新的主版本必须使用和之前版本不同的模块路径。从 v2 开始，主版本号必须出现在模块路径的结尾（在 go.mod 文件的 module 语句中声明）。例如，当模块 github.com/googleapis/gax-go 的开发者们开发完 v2 ，他们用了新的模块路径 github.com/googleapis/gax-go/v2 。想要使用 v2 的用户必须把他们的包导入和模块要求更改为 github.com/googleapis/gax-go/v2 需要主版本号后缀是 Go 模块和大多数其他依赖管理系统不同的方式之一。后缀用于解决菱形依赖问题。在 Go 模块之前，gopkg.in 允许软件包维护者遵循我们现在称为导入兼容性规则的内容。使用 gopkg.in 时，如果你依赖一个导入了 gopkg.in/yaml.v1 的包以及另一个导入了 gopkg.in/yaml.v2 的包，这不会发生冲突，因为两个 yaml 包有着不同的导入路径（它们使用和 Go Modules 类似的版本后缀）。由于 gopkg.in 和 Go Modules 共享相同的版本号后缀方法，因此 Go 命令接受 gopkg.in/yaml.v2 中的 .v2 作为有效的版本号。这是一个为了和 gopkg.in 兼容的特殊情况，在其他域托管的模块需要使用像 /v2 这样的斜杠后缀。\n主版本策略 推荐的策略是在以主版本后缀命名的目录中开发 v2+ 模块。\ngithub.com/googleapis/gax-go @ master branch /go.mod → module github.com/googleapis/gax-go /v2/go.mod → module github.com/googleapis/gax-go/v2 这种方式与不支持 Go Modules 的一些工具兼容：仓库中的文件路径与 GOPATH 模式下 go get 命令预期的路径匹配。这一策略也允许所有的主版本一起在不同的目录中开发。\n其他的策略可能是将主版本放置在单独的分支上。然而，如果 v2+ 的源代码在仓库的默认分支上（一般是 master），不支持版本的工具（包括 GOPATH 模式下的 Go 命令）可能无法区分不同的主版本。\n本文中的示例遵循主版本子目录策略，所以提供了最大的兼容性。我们建议模块的作者遵循这种策略，只要他们还有用户在使用 GOPATH 模式开发。\n发布 v2 及更高版本 这篇文章以 github.com/googleapis/gax-go 为例：\n$ pwd /tmp/gax-go $ ls CODE_OF_CONDUCT.md call_option.go internal CONTRIBUTING.md gax.go invoke.go LICENSE go.mod tools.go README.md go.sum RELEASING.md header.go $ cat go.mod module github.com/googleapis/gax-go go 1.9 require ( github.com/golang/protobuf v1.3.1 golang.org/x/exp v0.0.0-20190221220918-438050ddec5e golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3 golang.org/x/tools v0.0.0-20190114222345-bf090417da8b google.golang.org/grpc v1.19.0 honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099 ) $ 要开始开发 github.com/googleapis/gax-go 的 v2 版本，我们将创建一个新的 v2/ 目录并将包的内容复制到该目录中。\n$ mkdir v2 $ cp *.go v2/ building file list ... done call_option.go gax.go header.go invoke.go tools.go sent 10588 bytes received 130 bytes 21436.00 bytes/sec total size is 10208 speedup is 0.95 $ 现在，我们通过复制当前的 go.mod 文件并且在 module 路径上添加 /v2 后缀来创建属于 v2 的 go.mod 文件。\n$ cp go.mod v2/go.mod $ go mod edit -module github.com/googleapis/gax-go/v2 v2/go.mod $ 注意： v2 版本被视为与 v0 / v1 版本分开的模块，两者可以共存于同一构建中。因此，如果你的 v2+ 模块具有多个软件包，你应该更新它们使用新的 /v2 导入路径，否则，你的 v2+ 模块会依赖你的 v0 / v1 模块。要升级所有 github.com/my/project 为 github.com/my/project/v2 ，可以使用 find 和 sed 命令：\n$ find . -type f \\  -name \u0026#39;*.go\u0026#39; \\  -exec sed -i -e \u0026#39;s,github.com/my/project,github.com/my/project/v2,g\u0026#39; {} \\; $ 现在我们有了一个 v2 模块，但是我们要在版本发布之前进行实验并进行修改。在我们发布 v2.0.0 （或者其他没有预发布后缀的版本）之前，我们可以进行开发并且可以做出重大变更，就如同我们决定实现新 API 一样。 如果我们希望用户能够在正式发布新 API 之前对其进行试验，可以选择发布 v2 预发布版本：\n$ git tag v2.0.0-alpha.1 $ git push origin v2.0.0-alpha.1 $ 一旦我们对 v2 API 感到满意并且确定不会再有别的重大变更，我们可以打上 Git 标记 v2.0.0 。\n$ git tag v2.0.0 $ git push origin v2.0.0 $ 到那时，就有两个主版本需要维护。向后兼容的更改和错误修复使用新的次版本或者补丁版本发布（比如 v1.1.0 ， v2.0.1 等）。\n总结 主版本变更会带来开发和维护的开销，并且需要下游用户的额外付出才能迁移。越大的项目中这种主版本变更的开销就越大。只有在确定了令人信服的理由之后，才应该进行主版本变更。一旦确定了令人信服的重大变更原因，我们建议在 master 分支进行多个主版本的开发，因为这样能与各种现有工具兼容。\n对 v1+ 模块的重大变更应该始终发生在新的 vN+1 模块中。一个新模块发布时，对于维护者和需要迁移到这个新软件包的用户来说意味着更多的工作。因此，维护人员应该在发布稳定版本之前对其 API 进行验证，并仔细考虑在 v1 版本之后是否确有必要进行重大变更。\n相关文章  发布 Go Modules 启用模块镜像和校验数据库 迁移到 Go Modules 使用 Go Modules 2019 年的 Go Modules Go 中软件包版本控制的建议 封面故事 App Engine SDK 和工作区 组织 Go 代码 ","id":1,"section":"posts","summary":"\u003cp\u003e本文是一篇翻译文章: \u003ca href=\"https://blog.golang.org/v2-go-modules\"\u003ehttps://blog.golang.org/v2-go-modules\u003c/a\u003e \n原文作者：\u003ca href=\"https://blog.golang.org/\"\u003eJean de Klerk 和 Tyler Bui-Palsu\u003c/a\u003e  译者：\u003ca href=\"https://github.com/befovy\"\u003ebefovy\u003c/a\u003e   校对：\u003ca href=\"https://github.com/polaris1119\"\u003epolaris1119\u003c/a\u003e \n译文由 \u003ca href=\"https://github.com/studygolang/GCTT\"\u003eGCTT\u003c/a\u003e 原创编译，\u003ca href=\"https://studygolang.com/articles/25130\"\u003eGo语言中文网\u003c/a\u003e 荣誉推出\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"heading\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e本文是 Go modules 系统的第四部分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePart 1: \u003ca href=\"https://blog.golang.org/using-go-modules\"\u003e使用 Go Modules\u003c/a\u003e  \u003ca href=\"https://studygolang.com/articles/19334\"\u003e译文\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 2: \u003ca href=\"https://blog.golang.org/migrating-to-go-modules\"\u003e迁移到 Go Modules\u003c/a\u003e  \u003ca href=\"https://studygolang.com/articles/23133\"\u003e译文\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 3: \u003ca href=\"https://blog.golang.org/publishing-go-modules\"\u003e发布 Go Modules\u003c/a\u003e \u003ca href=\"https://studygolang.com/articles/25129\"\u003e译文\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 4: \u003ca href=\"https://blog.golang.org/v2-go-modules\"\u003eGo Modules : v2 及更高版本\u003c/a\u003e (本文) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e随着成功的项目逐渐成熟以及新需求的加入，早期的功能和设计决策可能不再适用。 开发者们可能希望通过删除废弃使用的功能、重命名类型或将复杂的程序拆分为可管理的小块来融入他们的经验教训。这种类型的变更要求下游用户进行更改才能将其代码迁移到新的 API，因此在没有认真考虑收益成本比重的情况下，不应进行这种变更。\u003c/p\u003e","tags":["golang"],"title":"Go Modules : v2 及更高版本","uri":"https://blog.befovy.com/2019/12/v2-go-modules/","year":"2019"},{"content":"20191205 更新\n经过 v2ex v友提醒，发现了更牛逼更方便的 cdn jsdelivr。 jsdelivr 能自动为 github 仓库内容提供 cdn 加速服务，只需要换一下网址即可。\n对比下这俩地址，一个经过了 cdn 加速，一个是直接访问 github。\nhttps://cdn.jsdelivr.net/gh/befovy/blogback@master/docs/ https://github.com/befovy/blogback/tree/master/docs\n 本文中的内容除了自动压缩图片，其他都已经过时。\n之前在 github pages 上部署的博客图片访问一直很慢，主要是没钱买图床。 今天又花功夫用 gitee 和其他的工具给自己做了一个图床。\ngitee 做图床的优点：\n 访问速度快  结合本文提供的一套工具组合可以实现：\n 图片选中一键上传 剪贴板图片一键上传 上传完成后复制图片网址到剪贴板 图片上传自动压缩 依然完全免费  文中用到的工具  码云 gitee ，使用码云中的公开仓库作为图床，可以外链访问 github，图片自动上传到 github 公开仓库 github actions 自动把 github 仓库中的图片同步到 gitee 仓库 github app ImgBot 自动压缩图片 github actions 自动合并 ImgBot 发起的图片压缩后的 pull request PicGo 图片自动上传  搭建步骤 搭建步骤中是有一些问题费了些时间，但是有了我帮你踩了所有的坑并且总结这篇教程后，看到这里的你一定能够顺利搭建自己的免费好用的图床。\n本文教程使用了 github action，如果你的 github 还有没激活 actions 的话，你可以使用其他的 ci 工具实现。 github 仓库中如果看不到下面这个 actions 图标，就说明还不支持 actions 功能。 github 仓库和设置 首先需要创建一个 github 仓库，比如 https://github.com/befovy/images ，创建步骤略过。\n为 github 仓库安装 ImgBot 机器人。 打开 ImgBot 网站，点击 【try for free】， ImgBot 声称开源项目能够一直免费使用其服务。 从 ImgBot 网站跳转到 github 网站后，点击 【Set up a plan】 按钮，在下一步中选择 【Open Source】 这一个免费计划。下一步是【Install it for free】。 最后到这下图这个步骤，你可以选择为所有仓库开启此功能，也可以只选择为刚刚创建的图床仓库打开 ImgBot。\n使用 github actions 自动同步到 gitee 在 gitee 也上创建一个仓库用来保存图床图片。然后为 gitee 新建一个 ssh key。并把公钥增加在 gitee 账户的设置中。\n在之前创建的 github 图床仓库中编辑 actions 配置文件，新增一个 .github/workflows/gitee.yml\nname:Pushtogiteeon:push:branches:-masterjobs:build:runs-on:ubuntu-lateststeps:-uses:actions/checkout@v1-name:SetSSHKeyenv:SSH_KEY:${{secrets.GITEE_SSH_KEY}}SSH_KEY_PUB:${{secrets.GITEE_SSH_PUB}}run:| mkdir -p ~/.sshssh-keyscan-Hgitee.com\u0026gt;\u0026gt;~/.ssh/known_hostsecho${SSH_KEY}\u0026gt;~/.ssh/id_rsased-i-e\u0026#34;s#\\\\\\\\n#\\n#g\u0026#34;~/.ssh/id_rsachmod600~/.ssh/id_rsaecho${SSH_KEY_PUB}\u0026gt;~/.ssh/id_rsa.pubchmod600~/.ssh/id_rsa.pub-name:Pushtogiteerun:| git switch -c mastergitremoteaddgiteegit@gitee.com:befovy/images.gitgitpush--set-upstreamgiteemaster-f这个 actions 中主要是 checkout 当前仓库文件，配置 gitee 的 ssh 密钥，推送 git 仓库到 gitee。\n密钥不能明文写在 actions 配置文件，需要保存在仓库的设置中。 在 github 仓库 设置选项中，选择左侧的 Secrets。把前面生成的 ssh 公钥和私钥都保存起来。注意私钥本身由好多行组成，但是 actions secrets 这里好像换行符会出问题，所以我们先把私钥中所有的换行用 \\n 替换掉，替换完后私钥只剩下一行文本。 保存在这个页面的 secrets 可以在 actions 配置中使用。 我保存的名称分别是 GITEE_SSH_KEY 和 GITEE_SSH_PUB ，在 actions 配置文件中的使用方式是 ${{ secrets.GITEE_SSH_KEY }} 。\n在 gitee.yml 中，我从 secrets 中取出私钥，保存在 .ssh/id_rsa 中又通过命令把其中的 \\n 全部换成了真正的换行符。 这就是我踩过的一个大坑，不这么做后面 git push 会出错。\n配置好 ssh 后，可以通过 git 命令把仓库内容 push 到 gitee 中去。 注意，github actions 中的 checkout 检出当前内容后，git 是在一个游离状态，没有分支名。需要先 git switch -c master 设置当前为 master 分支。\nPicGo 配置 PicGo 是用 Electron-Vue 开发的一个图片自动上传至图床的工具。先下载安装 PicGo 到电脑中。 PicGo 支持 github、新浪、七牛等多种图床。也可以安装插件支持 gitee 图床，但是 gitee 上不能配置图片自动压缩，所以我在 github 绕了一圈，图片在 github 压缩后再同步到 gitee。\nPicGo 设置如图， 我用了 githubPlus 插件，其实用默认的 github 图床功能就行。\n图中用到的 token 在 https://github.com/settings/tokens 页面生成。\n自己修改一下 PicGo 的上传图片快捷键，选择一张图片上传。上传完成后 url 会自动复制到剪切板。 等 github actions 执行完成后，就可以通过剪贴板中的 url 访问到保存在 gitee 的图片了， gitee 的图片访问确实很快。\ngithub actions 自动合并 ImgBot 的 pr 上传图片后，很快 ImgBot 就会对图片进行压缩，并在 github 的仓库中发起一个 pull request。手动点击合并按钮对我来说实在是太麻烦了，能不能自动搞呢。有了 actions 没啥不能的，\n在 github actions 配置新增一个文件，.github/workflow/merge.yml\nname:MergeImgboton:pull_request:types:-opened-ready_for_reviewpull_request_review:types:-submittedstatus:{}jobs:automerge:runs-on:ubuntu-lateststeps:-name:automergeuses:\u0026#34;pascalgn/automerge-action@v0.6.1\u0026#34;env:GITHUB_TOKEN:\u0026#34;${{ secrets.GIT_MERGE_TOKEN }}\u0026#34;MERGE_LABELS:\u0026#34;\u0026#34;MERGE_METHOD:\u0026#34;squash\u0026#34;MERGE_COMMIT_MESSAGE:\u0026#34;pull-request-description\u0026#34;MERGE_FORKS:\u0026#34;false\u0026#34;MERGE_RETRIES:\u0026#34;2\u0026#34;MERGE_RETRY_SLEEP:\u0026#34;10000\u0026#34;UPDATE_METHOD:\u0026#34;rebase\u0026#34;这个 actions 配置中用到了 pascalgn/automerge-action，简化了对于 pull request 的操作。 注意设置 MERGE_LABLES 要留空，否则你必须给 pull request 打上对应的 lable 后，才能自动合并。 这里再一次用到了 secrets 保存了 github token，和上一步配置 PicGo 用到的 token 一样。\n现在的流程是：\n 电脑中 PicGo 客户端自动上传图片到 github 仓库。 master 分支的 push 操作触发 actions 将仓库同步到 gitee。 ImgBot 稍后会发起 pull request 合并经过压缩的图片 pull request 触发 actions 自动进行分支合并，并 push 到目标分支(master) master 分支 push 操作再次触发 actions 将仓库同步到 gitee。  手动触发步骤1后，其余步骤完全自动化运行。进一步步骤2还可以省去一些环境。\n-name:Pushtogiteerun:| git switch -c mastergitremoteaddgiteegit@gitee.com:befovy/images.gitimgbot=`gitrev-parseHEAD|gitshow-s--format=\u0026#39;%ae\u0026#39;|grepimgbot`||echo\u0026#34;no imgbot\u0026#34;[[!-z\u0026#34;$imgbot\u0026#34;]]\u0026amp;\u0026amp;gitpush--set-upstreamgiteemaster-f||echo\u0026#34;Ingore push\u0026#34;判断提交作者是否是 imgbot，如果不是，不进行 push 到 gitee 的操作。\n 完结\n","id":2,"section":"posts","summary":"\u003cp\u003e20191205 更新\u003c/p\u003e\n\u003cp\u003e经过 v2ex v友提醒，发现了更牛逼更方便的 cdn jsdelivr。\njsdelivr 能自动为 github 仓库内容提供 cdn 加速服务，只需要换一下网址即可。\u003c/p\u003e\n\u003cp\u003e对比下这俩地址，一个经过了 cdn 加速，一个是直接访问 github。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://cdn.jsdelivr.net/gh/befovy/blogback@master/docs/\"\u003ehttps://cdn.jsdelivr.net/gh/befovy/blogback@master/docs/\u003c/a\u003e \u003cbr\u003e\n\u003ca href=\"https://github.com/befovy/blogback/tree/master/docs\"\u003ehttps://github.com/befovy/blogback/tree/master/docs\u003c/a\u003e\u003c/p\u003e","tags":null,"title":"我的 gitee 图床，自动上传、压缩、获取图片 url","uri":"https://blog.befovy.com/2019/11/gitee-image-bed/","year":"2019"},{"content":" 认真读完本文就能掌握编写一个 Flutter 系统音量插件的技能，支持调节系统音量以及监听系统音量变化。 如有不当之处敬请指正。\n 0、背景 我最近在做一个 Flutter 视频播放器插件 fijkplayer，感兴趣可以看我的 github。在 0.1.0 版本之后考虑增加调节系统音量功能。google 一番，找到了相关的 Flutter 插件（Flutter 的生态真的是建立挺快的）。但仔细了解插件的功能之后，感觉有些不满足我的需求，同时由于我的 fijkplayer 本身就是一个插件，想尽量避免依赖额外的插件，所以我干嘛不自己动手造一个？这可比播放器插件简单多了。本文写作时播放器插件 fijkplayer 上已经完成了音量调节和监控的功能，为了文档内容清晰，把相关的代码又单独抽出来作为一个小项目 flutter_volume 。\n1、环境介绍 搭建 Flutter 环境这里不专门讲了。直接从 Flutter 插件的开发环境入手。本文使用的 Flutter 版本和环境是 [✓] Flutter is fully installed. (Channel stable, v1.9.1+hotfix.2, on Mac OS X 10.14.6 18G95, locale zh-Hans-CN) 创建插件 新建一个叫做 flutter_volume 的 Flutter 插件：flutter create --org com.befovy -t plugin -i objc flutter_volume 。flutter create 命令使用参数 -t 选择模版，可选值为 app package plugin，分别用于创建 Flutter 应用程序，Flutter 包（纯 dart 代码实现的功能）， Flutter 插件（和主机系统交互）。\n我在开始写 fijkplayer 的时候，默认插件语言还是 java 和 objc，现在1.9 版本，都已经默认使用 kotlin 和 swift 了。Swift 我还不太熟悉，kotlin 了解一些，并且 Android studio 的 java 转换 kotlin 很强大，我这里新的小项目 flutter_volume 就也使用 kotlin 和 objc 了。如果要修改创建 Flutter 插件使用的编程语言，可以使用参数 -i 和 -a 。例如 flutter create -t plugin -a java -i swift flutter_volume\n插件目录结构 先在 Android Studio 中安装 Flutter 插件和 Dart 插件。 然后使用 Android Studio 打开刚才创建的 plugin 项目目录 flutter_volume。注意是使用 Android Studio 中的 “Open an existing Android Studio project\u0026rdquo; 菜单。\n使用 Android Studio 打开 Flutter 项目后，其结构如下。Flutter plugin 的功能实现基本上就是 dart 代码和 android 本地 kotlin/java 以及 iOS 本地 swift/objc 代码互相调用。实现这些功能的代码就在下图中 libs 目录中的 dart 源文件，android/src 目录中的 java/kotlin 源文件，以及 ios/Classes 目录中的 objc/swift 源文件。在这个 Android Studio 工程中随便打开一个 android 目录内的文件，都会编辑器右上角出现 “Open for Editing in Android Studio” 的可点击链接，打开 ios 文件夹的任意文件，都会出现类似 “Open for Editing in XCode” 的可点击链接。\n在我使用的这个版本 flutter 中，新项目直接使用 Xcode 打开会存在一些问题。解决办法是先在 example/ios 文件夹，运行 pod install 。之后再点击 “Open for Editing in XCode” 打开 Xcode 项目，或者使用 Xcode 打开 example/ios/Runner.xcworkspace 工程。划重点先在命令后 example/ios 文件夹，运行 pod install，然后再打开 Xcode 项目。\n打开 xcode 后看到，插件的 objc/swift 代码被 pod 使用文件链接套了很长的路径，写iOS插件主要就是在这个文件夹的代码中实现功能。（截图还是 swift 的插件项目，后来为了进度改成了 objc，毕竟对 swift 不太熟悉）\n点击 Open for Editing in Android Studio 打开新的 Android Studio 项目，等 gradle 自动同步完成。 这是一个完整的 Android App 工程，flutter_volume 插件作为一个 Android 工程的 modue 存在。插件的功能实现也主要是修改这个 module 中的代码。\n上面的 Xcode 工程以及这个 Android Studio 工程，都是可以运行的 App 工程，这个 Flutter 工具已经帮我们打理好了，创建 Flutter plugin 的时候就默认带有 example。上面大图 1 中 example 文件夹中的目录结构就和一个普通的 Flutter App 目录结构一样，只是这里 Flutter App 使用相对路径依赖的外层文件夹的 flutter_volume 插件。大图 2 和 大图 3 打开的其实就是 example 文件中 android 和 iOS 项目。\n这种 Flutter 工具自动生成的插件目录结构确实对程序员非常友好，写了插件立马就能在 demo 中看到效果。\n2、Flutter Native 通信方式 Flutter 应用可以在 iOS 和 Android 平台运行，肯定要和原生系统进行各种各样的交互。交互的部分主要是在 flutter engine 中，以及大量的 flutter 插件中。\nMethodChannel Flutter 框架提供了这样的交互方式。消息通过 Method Channel 在客户端（UI）和主机（platform）之间传递。官方文档这里使用的是 platform channels，翻译的时候我使用了更具体直接的表述 Method Channel见下图（图片来源 https://flutter.dev/docs/development/platform-integration/platform-channels）\n翻译一段官方的释义\n 在客户端，MethodChannel 可以发送与方法调用相对应的消息。 在平台方面，Android 上的 MethodChannel和 iOS 上的 FlutterMethodChannel 允许接收方法调用并发送回结果。 这些类使您可以使用很少的“样板代码”来开发平台插件。 注意：如果需要，方法调用也可以反向发送，平台充当Dart中实现的方法的客户端。\n 上图形象表达了 Flutter 发送消息到 native 端的过程。同时，我们需要注意，这个过程可以反过来从 native 端主动发送消息到 Flutter 端。即在 native 端创建 MethodChannel 并进行方法调用，Flutter 端进行方法处理并且发送会方法调用结果。实际中更常用的是对于这个模式的更高一层封装 EventChannel。Native 端进行 event 发送，Flutter 端进行 event 响应。MethodChannel 和 EventChannel 都会在后面实战环节使用到，一看即会。\n在 Flutter 客户端和 native 平台方面传递数据都是需要经过编码再解码。编码的方式默认的是用StandardMethodCodec，此外还有 JSONMethodCodec 。StandardMethodCodec编解码效率更高。\n编码数据类型 MethodCodec 支持的数据类型以及在 dart 、iOS 和 Android 中的对应关系如下表。\n   Dart Android iOS     null null nil (NSNull when nested)   bool java.lang.Boolean NSNumber numberWithBool:   int java.lang.Integer NSNumber numberWithInt:   int, if 32 bits not enough java.lang.Long NSNumber numberWithLong:   double java.lang.Double NSNumber numberWithDouble:   String java.lang.String NSString   Uint8List byte[] FlutterStandardTypedData typedDataWithBytes:   Int32List int[] FlutterStandardTypedData typedDataWithInt32:   Int64List long[] FlutterStandardTypedData typedDataWithInt64:   Float64List double[] FlutterStandardTypedData typedDataWithFloat64:   List java.util.ArrayList NSArray   Map java.util.HashMap NSDictionary    3、Volume 接口 前面提到是要在一个视频播放器插件中调整系统的音量。经过梳理，先整理出初步需要的接口。主要有增大音量、减小音量、静音、获取音量、设置音量。同时还有激活音量变化监听、设置音量变化监听、关闭音量变化监听。为了使用方便，还增加了一个 VolumeWatcher 的 Widget，在其中成对使用了新增音量变化监听，取消音量变化监听接口。\n部分代码如下，完整代码请 点击链接查看 。\nclass VolumeVal { final double vol; final int type; } typedef VolumeCallback = void Function(VolumeVal value); class FlutterVolume { static const double _step = 1.0 / 16.0; static const MethodChannel _channel = const MethodChannel('com.befovy.flutter_volume'); static _VolumeValueNotifier _notifier = _VolumeValueNotifier(VolumeVal(vol: 0, type: 0)); static StreamSubscription _eventSubs; void enableWatcher() { if (_eventSubs == null) { _eventSubs = EventChannel('com.befovy.flutter_volume/event') .receiveBroadcastStream() .listen(_eventListener, onError: _errorListener); _channel.invokeMethod(\u0026quot;enable_watch\u0026quot;); } } void disableWatcher() { _channel.invokeMethod(\u0026quot;disable_watch\u0026quot;); _eventSubs?.cancel(); _eventSubs = null; } static void _eventListener(dynamic event) { final Map\u0026lt;dynamic, dynamic\u0026gt; map = event; switch (map['event']) { case 'vol': double vol = map['v']; int type = map['t']; _notifier.value = VolumeVal(vol: vol, type: type); break; default: break; } } static Future\u0026lt;double\u0026gt; up({double step = _step, int type = STREAM_MUSIC}) { return _channel.invokeMethod(\u0026quot;up\u0026quot;, \u0026lt;String, dynamic\u0026gt;{ 'step': step, 'type': type, }); } static void addVolListener(VoidCallback listener) { _notifier.addListener(listener); } } class VolumeWatcher extends StatefulWidget { final VolumeCallback watcher; final Widget child; VolumeWatcher({ @required this.watcher, @required this.child, }); @override _VolumeWatcherState createState() =\u0026gt; _VolumeWatcherState(); } 这里既使用了 MethodChannel， 也使用了 EventChannel。Flutter 使用 MethodChannel 发送方法调用请求到 native 侧，并获取方法的调用结果。为了避免 UI 卡顿，方法调用都使用异步模式。EventChannel 则是在 Flutter 端处理 native 发送的事件通知。在 Flutter 中，所有 Channel 的 name 必须是不重复的，否则消息发送会出错。\n MethodChannel 的使用很简单，使用 name 参数构造一个 MethodChannel ，并使用 invokeMethod 进行消息和参数的发送，并返回异步的结果。 EventChannel 使用稍微复杂一些，但都是一些样板代码。构造 EventChannel 并监听事件广播，注册事件处理函数和错误处理函数。使用完成后再取消广播订阅。  接口设计中，我加上了不同音频类型的可选参数 type ，但在初期的实现中，只会实现媒体声音类型的相关功能。这个可选参数保证后期的功能实现，接口不发生变化。\n完整的代码变更可以看github 上这个提交。https://github.com/befovy/flutter_volume/commit/c8ff0f583b3372d22f764bcaf377f1a6bc64cf39\n4、iOS 功能实现 FlutterPluginRegistrar FlutterPluginRegistrar 是 flutter 插件在 iOS 环境中的上下文，提供插件上下文信息，以及 App 回调事件信息。FlutterPluginRegistrar 的实例对象需要保存在 Plugin class 的成员变量中，方便后续使用。将 FlutterVolumePlugin 的无参 init 函数调整为 initWithRegistrar 。\n@implementation FlutterVolumePlugin + (void)registerWithRegistrar:(NSObject\u0026lt;FlutterPluginRegistrar\u0026gt; *)registrar { FlutterMethodChannel *channel = [FlutterMethodChannel methodChannelWithName:@\u0026#34;com.befovy.flutter_volume\u0026#34; binaryMessenger:[registrar messenger]]; FlutterVolumePlugin *instance = [[FlutterVolumePlugin alloc] initWithRegistrar:registrar]; [registrar addMethodCallDelegate:instance channel:channel]; } - (instancetype)initWithRegistrar: (NSObject\u0026lt;FlutterPluginRegistrar\u0026gt; *)registrar { self = [super init]; if (self) { _registrar = registrar; } return self; } @end iOS 监听音量变化 ios 系统通知中心有关于音量变化的广播，监听音量变化只需要在通知中心注册通知即可。根据接口设计，监听系统音量变化，有两个接口调用控制功能开启或者关闭。音量监听的主要代码实现如下：\n@implementation FlutterVolumePlugin - (void)enableWatch { if (_eventListening == NO) { _eventListening = YES; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeChange:) name:@\u0026#34;AVSystemController_SystemVolumeDidChangeNotification\u0026#34; object:nil]; _eventChannel = [FlutterEventChannel eventChannelWithName:@\u0026#34;com.befovy.flutter_volume/event\u0026#34; binaryMessenger:[_registrar messenger]]; [_eventChannel setStreamHandler:self]; } } - (void)disableWatch { if (_eventListening == YES) { _eventListening = NO; [[NSNotificationCenter defaultCenter] removeObserver:self name:@\u0026#34;AVSystemController_SystemVolumeDidChangeNotification\u0026#34; object:nil]; [_eventChannel setStreamHandler:nil]; _eventChannel = nil; } } - (void)volumeChange:(NSNotification *)notification { NSString *style = [notification.userInfo objectForKey:@\u0026#34;AVSystemController_AudioCategoryNotificationParameter\u0026#34;]; CGFloat value = [[notification.userInfo objectForKey:@\u0026#34;AVSystemController_AudioVolumeNotificationParameter\u0026#34;] doubleValue]; if ([style isEqualToString:@\u0026#34;Audio/Video\u0026#34;]) { [self sendVolumeChange:value]; } } - (void)sendVolumeChange:(float)value { if (_eventListening) { NSLog(@\u0026#34;valume val %f\\n\u0026#34;, value); [_eventSink success:@{@\u0026#34;event\u0026#34; : @\u0026#34;volume\u0026#34;, @\u0026#34;vol\u0026#34; : @(value)}]; } } @end enableWatch 中在通知中心注册关于音量变化的处理函数。然后构造 FlutterEventChannel 并且设置 handler。disableWatch 中移除在通知中心注册的回调，然后删除 EventChannel 的 handler，并删除 eventChannel 对象。需要注意的是，dart中 EventChannel('xxx').receiveBroadcastStream() 的调用一定要在 native 端执行完成 FlutterEventChannel setStreamHandler 方法之后，否则会出现 onListen 方法找不到的错误。\n系统音量修改 iOS 中没有公开的修改系统音量接口，但是还有其他途径实现音量修改。目前使用最广泛的就是在 UI 中插入一个不可见的 MPVolumeView，然后模拟 UI 操作调整其中的 MPVolumeSlider。\n@implementation FlutterVolumePlugin - (void)initVolumeView { if (_volumeView == nil) { _volumeView = [[MPVolumeView alloc] initWithFrame:CGRectMake(-100, -100, 10, 10)]; _volumeView.hidden = YES; } if (_volumeViewSlider == nil) { for (UIView *view in [_volumeView subviews]) { if ([view.class.description isEqualToString:@\u0026#34;MPVolumeSlider\u0026#34;]) { _volumeViewSlider = (UISlider *)view; break; } } } if (!_volumeInWindow) { UIWindow *window = UIApplication.sharedApplication.keyWindow; if (window != nil) { [window addSubview:_volumeView]; _volumeInWindow = YES; } } } - (float)getVolume { [self initVolumeView]; if (_volumeViewSlider == nil) { AVAudioSession *audioSession = [AVAudioSession sharedInstance]; CGFloat currentVol = audioSession.outputVolume; return currentVol; } else { return _volumeViewSlider.value; } } - (float)setVolume:(float)vol { [self initVolumeView]; if (vol \u0026gt; 1.0) { vol = 1.0; } else if (vol \u0026lt; 0) { vol = 0.0; } [_volumeViewSlider setValue:vol animated:FALSE]; vol = _volumeViewSlider.value; return vol; } @end 完整 iOS 插件代码 点我查看\n5、Android 功能实现 Android Flutter 插件开发离不开 flutter engine 中的接口 Registrar。通过 Registrar 的方法可以获取 activity、 context 等 Android 开发中重要对象。\nRegistrar public interface Registrar { Activity activity(); Context context(); Context activeContext(); .... }  class FlutterVolumePlugin(registrar: Registrar): MethodCallHandler { companion object { @JvmStatic fun registerWith(registrar: Registrar) { val channel = MethodChannel(registrar.messenger(), \u0026quot;flutter_volume\u0026quot;) channel.setMethodCallHandler(FlutterVolumePlugin(registrar)) } } private val mRegistrar: Registrar = registrar } 对自动生成的 Plugin class 进行修改，增加 mRegistrar 成员变量（见上面代码片段），在成员函数 onMethodCall 中处理 method call 的时候就可以获取 activity、context 等重要变量。\n比如 Android 系统中音量修改使用的 AudioManager 。\n class FlutterVolumePlugin(registrar: Registrar): MethodCallHandler { private fun audioManager(): AudioManager { val activity = mRegistrar.activity() return activity.getSystemService(Context.AUDIO_SERVICE) as AudioManager } } Android 中音量调节功能的实现主要就是 AudioManager 的 API 调用，以及对 flutter onMethodCall 方法的处理。详细的内容请点击查看源代码。\n监听音量的变化 Android 系统中使用广播通知 BroadcastReceiver 获取音量变化。根据接口设计，监听系统音量变化，有两个接口调用控制功能开启或者关闭。在 enableWatch 方法中，先修改标记变量 mWatching ， 然后创建 EventChannel 并且调用 setStreamHandler 方法。最后，注册广播接收器，接受系统音量变化的通知。需要注意的是，dart中 EventChannel('xxx').receiveBroadcastStream()的调用一定要在 native 端执行完成 setStreamHandler 方法之后，否则会出现 onListen 方法找不到的错误。\nclass FlutterVolumePlugin(registrar: Registrar) : MethodCallHandler { private fun enableWatch() { if (!mWatching) { mWatching = true mEventChannel = EventChannel(mRegistrar.messenger(), \u0026quot;com.befovy.flutter_volume/event\u0026quot;) mEventChannel!!.setStreamHandler(object : EventChannel.StreamHandler { override fun onListen(o: Any?, eventSink: EventChannel.EventSink) { mEventSink.setDelegate(eventSink) } override fun onCancel(o: Any?) { mEventSink.setDelegate(null) } }) mVolumeReceiver = VolumeReceiver(this) val filter = IntentFilter() filter.addAction(VOLUME_CHANGED_ACTION) mRegistrar.activeContext().registerReceiver(mVolumeReceiver, filter) } } private fun disableWatch() { if (mWatching) { mWatching = false mEventChannel!!.setStreamHandler(null) mEventChannel = null mRegistrar.activeContext().unregisterReceiver(mVolumeReceiver) mVolumeReceiver = null } } } 在获取音量变化通知 BroadcastReceiver 的 onReceive 方法中， 使用 EventChannel 发送到事件内容到 flutter 侧。\nprivate class VolumeReceiver(plugin: FlutterVolumePlugin) : BroadcastReceiver() { private var mPlugin: WeakReference\u0026lt;FlutterVolumePlugin\u0026gt; = WeakReference(plugin) override fun onReceive(context: Context, intent: Intent) { if (intent.action == \u0026quot;android.media.VOLUME_CHANGED_ACTION\u0026quot;) { val plugin = mPlugin.get() if (plugin != null) { val volume = plugin.getVolume() val event: MutableMap\u0026lt;String, Any\u0026gt; = mutableMapOf() event[\u0026quot;event\u0026quot;] = \u0026quot;vol\u0026quot; event[\u0026quot;v\u0026quot;] = volume event[\u0026quot;t\u0026quot;] = AudioManager.STREAM_MUSIC plugin.sink(event) } } } } class FlutterVolumePlugin(registrar: Registrar) : MethodCallHandler { fun sink(event: Any) { mEventSink.success(event) } } 详细的内容请点击查看源代码。\n音量区间映射 在 Android 系统中，音量最大值有可能不一样，范围不是 [0, 1]。此插件获取音量最大值后，将音量又线性映射到 [0, 1] 的范围中。另一点需要注意，android 音量调节不是无级调节，有一个调节的最小单元，将这个最小单元映射到 [0, 1] 范围中的一个 delta 值，并保证调节音量 step 值大于等于这个最小单元 delta 值，否则音量调节无效。在插件的 API 实现中，如果调用 up 或 down 接口， step 参数值小于 delta ，则会被修改为 delta 的值，保证 up 或 down 接口的调用都是有效的。\n6、插件 Demo flutter 插件创建的默认目录中都包含一个 example 文件夹。里面是一个完整的 flutter app 工程目录，使用相对路径的方式引用了外层文件夹中的 flutter 插件。\ndev_dependencies:flutter_volume:path:../在 lib/main.dart 中引入插件 import \u0026lsquo;package:flutter_volume/flutter_volume.dart\u0026rsquo;;\n然后简单写几个按钮，在 onPressed 中调用 flutter_volume.dart 中的API 就可以完整插件的示例 App。详细内容请看完整的源代码 example/lib/main.dart\n7、发布插件 完成了插件或者 dart 包的开发测试之后，可以将其发布到 Pub 上，这样其他开发人员就可以快捷方便地使用它。Flutter 的依赖管理 pubspec 支持通过本地路径和 Git 导入依赖，但使用 pub 可以更方便进行插件版本管理。\n volume flutter_volume 这几个名字都已经被占坑了，我就暂时不发布到 pub 了\n 发布插件到 pub ，需要登录 google 账号，请预先准备梯子。\n在发布之前，先检查 pubspec.yaml、README.md 以及 CHANGELOG.md 、 LICENSE 文件，以确保其内容的完整性和正确性。pubspec.yaml 里除了插件的依赖，还包含一些插件以及作者的元信息，需要把这些补上：\nname:flutter_volumedescription:APluginforVolumeControlandMonitoring,supportiOSandAndroidversion:0.0.1author:befovyhomepage:blog.befovy.com然后, 运行 dry-run 命令以查看插件是否还有别的问题:\nflutter packages pub publish --dry-run 如果命令输出 Package has 0 warnings ，则表示一切正常。最后，运行发布命令 flutter packages pub publish 如果是第一次发布，会提示验证 Google 账号。\nLooks great! Are you ready to upload your package (y/n)? y Pub needs your authorization to upload packages on your behalf. In a web browser, go to https://accounts.google.com/o/oauth2/auth?access_type=offline*****.....(省略一千字) Then click \u0026quot;Allow access\u0026quot;. Waiting for your authorization... Successfully authorized. Uploading... Successful uploaded package. 成功授权之后便可以继续上传，上传成功后，会提示 Successful uploaded package 。发布后，可以在 https://pub.dartlang.org/packages/${plugin_name} 查看发布情况。\n参考资料  https://flutter.dev/docs/development/platform-integration/platform-channels\n","id":3,"section":"posts","summary":"\u003cblockquote\u003e\n\u003cp\u003e认真读完本文就能掌握编写一个 Flutter 系统音量插件的技能，支持调节系统音量以及监听系统音量变化。\n如有不当之处敬请指正。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!-- raw HTML omitted --\u003e","tags":["Flutter"],"title":"手把手带你写 Flutter 系统音量插件","uri":"https://blog.befovy.com/2019/11/flutter-plugin-volume/","year":"2019"},{"content":"给 ijkplayer 增加了 cmake 构建方式，支持在 android studio 中进行 c 代码断点调试。\n直接上手请前往 https://github.com/befovy/ijkplayer#build-android-via-cmake\n如果想了解一下整个过程请继续阅读本文。\nijkplayer 简介 ijkplayer 是由 B 站开源的一款移动端播放器。基于 ffmpeg 中 ffplay 开发，并添加 android MediaCodec、iOS VideotTolbox 视频硬解码支持以及 opengles、NativeWindow(android) 渲染，在当前的移动直播热潮中，被大量使用。 但使用 ijkplayer 进行 android 播放器开发的过程中，调试起来稍微有些麻烦，官方提供了ndk 调试的几个patch 文件，并且有一段描述，是基于 ndk-build android.mk 工具链构建的。说实话由于没有做成开箱即用，我也没认真看过这部分内容。 由于我对 cmake 的了解更多一些，加之 google 官方也逐渐将 ndk 的工具链由 ndk-build 转向 cmake，并在 android studio 中对 cmake 提供了更好的支持。同时 cmake 也是跨平台的构建工具，方便后续将 ijkplayer 扩展至其它平台，所以我用 cmake 重新实现了 ijkplayer 的构建过程。\n只要不是修改 ffmpeg 的源代码，其它内容包括 ijkplayer 的 c 代码修改， java 层修改，都可以在 android studio 中一键运行、调试。\n关于 ijkplayer 内部核心代码的分析，多个线程的工作内容，解码部分，音视频同步控制等部分的更深入的介绍，可以参考金山云视频的分析文章 https://www.jianshu.com/p/daf0a61cc1e0 ， 我最开始也是从这一篇文章入手逐渐读懂 ijkplayer 源代码的。\n题外话：ijkplayer 在 github 上的提交记录自 k0.8.8 版本之后就再也没有了，好多人评论说项目已经放弃维护了，但是细心寻找会发现在另一个项目 Bilibili/ffmpeg 中，还不断有提交记录。说明项目还是在不断开发，只是重心放在实现新的 ffmpeg protocol 上，没有及时维护 ijkplayer 项目上的 issues。\n下面具体说说一些具体的修改内容。\nandroid 工程结构调整 ijkplayer 的项目本身具有多个 android module。\nijkplayer-arm64\rijkplayer-armv5\rijkplayer-armv7a\rijkplayer-x86\rijkplayer-x86_64 # 上面几个都是一个module 壳，shell 命令编译好 so 库放在指定目录中\rijkplayer-example # 示例APP项目\rijkplayer-exo # 对 google exoplayer 的一层封装适，配合ijkplayer 定义的 mediaplyer 接口\rijkplayer-java # ijkplayer java 层代码，对接 native 层代码，以及硬解码器的选择\r项目中为不同的 cpu 架构都单独设置了 module，这几个 module 最大的区别就是在 Application.mk 中 APP_ABI 和 APP_PLATFORM 的值不同，其中 APP_PLATFORM 取值和 build.gradle 中定义的 minSdkVersion 相同。 ijkplayer 最低竟然支持 sdk version 9，确实感谢 B 站项目组初期在这方面的辛苦付出。\n这种 module 确实方便采用 ndk-build 工具的项目管理，但是我在使用过程中还是觉得有些不太方便之处：\n 在 android studio 中搜索 c 代码，搜索结果中重复出现多次 android studio 中的 c 代码没有语法高亮。  对于问题1，我找到的解决方案是：\n//NOTE:: run `./gradlew ideaModule` to apply exclude dirs\rapply plugin: \u0026#39;idea\u0026#39;\ridea.module {\rexcludeDirs += file(\u0026#39;ijkplayer-armv7a/src/\u0026#39;)\rexcludeDirs += file(\u0026#39;ijkplayer-arm64/src/\u0026#39;)\rexcludeDirs += file(\u0026#39;ijkplayer-armv5/src/\u0026#39;)\rexcludeDirs += file(\u0026#39;ijkplayer-x86/src/\u0026#39;)\rexcludeDirs += file(\u0026#39;ijkplayer-x86_64/src/\u0026#39;)\r}\r在工程根 build.gradle 中增加这样的配置，并执行 ./gradlew ideaModule， 就会在搜索结果中排除来自这几个文件夹的内容。\n对于问题2，我当然是用 cmake 解决了，新建一个 module, 取名 fijkplayer-full。换个名字方便和原项目进行区分，同时 f 也表示full, 我在这个 module 中囊括了原来 6 个 module 提供的内容。 f 还有别的含义，有机会在其它地方会提到。 在 fijkplayer-full 的 build.gradel 中增加 cmake 的配置以及引入 ijkplayer-java module 的 java 源代码。\nandroid {\r.......\r.......\rsourceSets.main {\rjava.srcDirs = [\u0026#34;$rootProject.rootDir/ijkplayer-java/src/main/java/\u0026#34;]\rjni.srcDirs = [] // This prevents the auto generation of Android.mk\r }\rexternalNativeBuild {\rcmake {\rpath \u0026#39;src/main/CMakeLists.txt\u0026#39;\r}\r}\r}\r修改后，fijkplayer-full 就成了 \u0026ldquo;六神合体\u0026rdquo; 了。\n对于不同cpu 架构区分不同的 minSdkVersion 可以通过 productFlavors 实现，这一块我还没有具体考虑充分，目前是统一设置了大家用得最多的 minSdkVersion 16。\n此部分修改的完整内容点我查看, github.com/befovy/ijkplayer\nCMakeLists.txt 编写 CMakeLists.txt 完全是个翻译工作，将 Android.mk 中的规则翻译过来就行。完成后通过 CMake 方式最终生成的 aar 和原始方式生成的aar 文件大小几乎没什么差别，见下图。 fijkplayer-full 只编译了 armv7a 架构，和 ijkplayer-armv7a 模块编译结果的对比。 fijkplayer-full 中 classes.jar 较大是因为包含了 ijkplayer-java module 中的内容。 还可以调整CMake 参数进一步减小生成库的大小。 转到 CMake 工具链的过程还遇到下面几个问题。\nlibffmpeg.so 找不到\nlibffmpeg.so 是事先通过 shell 命令编译成的，在 ffmpeg build 文件夹中，并且几乎不会改变，除非是要修改 ffmpeg。 在 CMake 中通过\nadd_library(ijkffmpeg SHARED IMPORTED)set_target_properties( # Specifies the target library.\r ijkffmpeg\r PROPERTIES\r IMPORTED_LOCATION ${FFMPAG_SHARED_DIR}/libijkffmpeg.so\r )引入预编译好的 ijkffmpeg，在编译 ijkplayer 的过程可以顺利完成链接。但是打包运行找不到 libijkffmpeg.so。分析最终的 apk 以及 fijkplayer-full.aar ，发现其中都没有 libijkffmpeg.so 文件，所以是打包 aar 的时候没有将这个文件打包进去。查看工程目录结构，发现编译好的 libijkplayer.so 和 libijksdl.so 都在文件夹 /build/intermediates/cmake/debug/obj/armeabi-v7a 中，所以还需要修改 CMakeLists.txt 在每次编译的时候将 libijkffmpeg.so 复制过去。最后的解决方案是\nadd_library(ijkffmpeg SHARED IMPORTED)set_target_properties( # Specifies the target library.\r ijkffmpeg\r PROPERTIES\r IMPORTED_LOCATION ${FFMPAG_SHARED_DIR}/libijkffmpeg.so\r )add_custom_target(cpffmpeg\r COMMAND mkdir -p ${CMAKE_LIBRARY_OUTPUT_DIRECTORY} COMMAND cp ${FFMPAG_SHARED_DIR}/libijkffmpeg.so ${CMAKE_LIBRARY_OUTPUT_DIRECTORY} )add_dependencies(ijkffmpeg cpffmpeg)没有找到一条命令能够解决的，所以麻烦了一点多写了点，用两个cmake 命令解决。\ncpufeatures 编译出错\n原项目中用到了 ndk 中的 cpufeatures，我在 CMake 文件中也引入并编译了 cpufeatures，但在编译 x86 以及 x86_64 架构的时候却出现了编译错误，具体是一处未识别的汇编指令。 最后发现是 ndk r15c 版本中 文件 $ANDROID_NDK/sources/android/cpufeatures/cpu-features.c 中少了几个换行符，补上之后（下面内容）编译就没问题了。\nstatic __inline__ void x86_cpuid(int func, int values[4])\r{\rint a, b, c, d;\r/* We need to preserve ebx since we\u0026#39;re compiling PIC code */\r/* this means we can\u0026#39;t use \u0026#34;=b\u0026#34; for the second output register */\r__asm__ __volatile__ ( \\\r\u0026#34;push %%ebx\u0026#34;\r\u0026#34;cpuid\\n\u0026#34; \\\r\u0026#34;mov %%ebx, %1\\n\u0026#34;\r\u0026#34;pop %%ebx\\n\u0026#34;\r: \u0026#34;=a\u0026#34; (a), \u0026#34;=r\u0026#34; (b), \u0026#34;=c\u0026#34; (c), \u0026#34;=d\u0026#34; (d) \\\r: \u0026#34;a\u0026#34; (func) \\\r);\rvalues[0] = a;\rvalues[1] = b;\rvalues[2] = c;\rvalues[3] = d;\r}\r意外的是我最终发现 ijkplayer 项目中没有用到 cpufeatures 的地方，可能是 gpl 协议的 android-ndk-profiler 部分用了吧，但项目中默认使用了一个假的 android-ndk-profiler，此部分没有去深究，性能分析使用 simpleperf 就足够了。 最后还是去掉 CMake 中 cpufeatures 的部分。\n此部分 CMakeLists.txt 的完整内容请看\nhttps://github.com/befovy/ijkplayer/blob/master/android/ijkplayer/fijkplayer-full/src/main/CMakeLists.txt\nhttps://github.com/befovy/ijkplayer/blob/master/ijkmedia/CMakeLists.txt\nhttps://github.com/befovy/ijkplayer/blob/master/ijkmedia/ijkplayer/CMakeLists.txt\nhttps://github.com/befovy/ijkplayer/blob/master/ijkmedia/ijksdl/CMakeLists.txt\n结束语 😄 附一张 NDK 断点调试的大图 👏\n刚开始写博客，可能有些啰嗦，多多包涵。或是没有说明白的地方，请大方的前往原始地址进行评论。\n最近对 Flutter 产生了兴趣，并打算用 ijkplayer 开发一个 Flutter 的播放器 Plugin， 祝我早日完成。\n 本文通过 mirror 和 hugo 生成，原始地址 https://github.com/befovy/blogback/issues/5\n tps://github.com/befovy/blogback/issues/5\n","id":4,"section":"posts","summary":"给 ijkplayer 增加了 cmake 构建方式，支持在 android studio 中进行 c 代码断点调试。 直接上手请前往 https://github.com/befovy/ijkplayer#build-android-via-cmake 如果想了解一下整个过程请继续阅读本文。 ijkplayer 简介 ijkplayer 是由 B 站开源的一款移动端","tags":null,"title":"用 CMake 为 ijkplayer 增加 android native debug 支持","uri":"https://blog.befovy.com/2019/06/issue_20190630_5/","year":"2019"},{"content":"一直觉得 Issue 是个特别好用的记录工具，看到很多人也直接把 Issue 作为个人博客。 Issue 可以碎片化的记录一些东西，然后在进行整理，最终形成一篇不错的博客内容。\nIssue 适合记录博客，但我觉得直接以 Issue 的形式将内容展示给读者还是缺少了博客本来的样子。毕竟Issue不支持自定义主题。\n我青睐的形式是：通过 Issue 进行写作，然后自动发布到博客站点。 所以就产生了 mirror 这个工具。\nmirror 能够自动抓取 github 项目里的 issue，并输出为 hugo 支持的构建格式。 通过 hugo 自动生成静态网页，最终通过自动工具实现部署。\n使用 github webhooks 以及很少的自动化脚本就可以实现这个过程的全自动化。\nmirror mirror 通过 github 提供的 graphql 进行 Issues 内容抓取。\n通过一些自定义规则，实现 Issues 内容的分类提取，并整理输出博客内容。\nmirror 规则\nmirror 配置文件 mirror 的配置文件使用 yaml 格式， 参考 conf.yaml 默认查找运行目录下的mirror.yaml 作为输入配置文件\n配置文件中可定义多个内容来源。 每一种不同的内容来源，都有其具体的配置项。\n内容来源 \u0026ldquo;issues\u0026rdquo; 具体的配置内容有\n token: github token, 需要有 issue 读取权限 login: github username repo: 要抓取的 issue 所在的 repo 名称 prefix: 输出文件名的统一前缀 output: 转换成 hugo 博客内容后的本地输出目录，建议指定为 hugo 博客的 content 目录  内容来源 Issue 的抓取规则\n draft  打开的Issue 视为博客草稿，不抓取。只抓取已经关闭的 Issue 内容。\ncontent  issue 本身有 body 和 comment。 新建issue时的内容是body， 之后所有项目本人和其它 githuber 的追加的内容都是评论。\nMirror 支持将 Issue body 和 comment 都抓取下来余与body部分拼接合并作为完整博客内容。\n由于 Issue 都是公开的，可能会被别人评论，作者还可能回复提问者。 为了区分这种情况，mirror 只拼接 comment 作者是项目作者本人， 且在 comment 开头有一句 html \u0026lt;!--mirror--\u0026gt; 注释语句的comment。\nhugo hugo 是一个非常棒的静态页面生成器，可以把 markdown 内容，搭配各种主题生成你想要的静态博客内容。 这些内容托管在 github pages 上博客就部署好了。\n完整步骤   生成项目 在当前目录下创建 blog 目录，并在其中生成hugo 项目的基本配置\nhugo new site ./blog\r  创建博客所需的github项目 github 上存在一个特殊的仓库名，可以自动生成静态站点方文仓库中的 html 文件。 这个仓库的具体命名规则是， \u0026lt;你的github账号\u0026gt;.github.io\n比如 befovy.github.io 对应自动生成网站的网址就是这个仓库的名称，https://befovy.github.io\n  在第二步的github 仓库中创建博客内容 新建 issue ，记录你的想法，完成之后关闭 issue。 如果想让一些issue 评论在最终生成的博客页面中也可见，在 issue 的评论开始输入 \u0026lt;!\u0026mdash;\u0026gt; 即可。\n  使用 mirror 工具自动抓去 issues 内容到 hugo 项目中 mirror 工具使用 go语言编写，目前没有提供直接可用的二进制包，需要从源码安装运行。 配置好 go 环境后，安装mirror\ngo get -u -v github.com/befovy/mirror\rcd $GOPATH/src/github.com/befovy/mirror\r按照 readme 中的说明设置所需配置文件，并运行程序\n  安装 hugo 主题 在hugo 主题中挑选一个自己喜欢的风格，安装到本地hugo项目中。 这里安装 even 主题作为示例。 安装主题后使用主题提供的默认hugo 项目配置\ngit clone https://github.com/olOwOlo/hugo-theme-even themes/even\rcp themes/even/exampleSite/config.toml ./\r  生成网站 运行 hugo 命令生成静态内容，注意这里需要设置 baseUrl。\nhugo --theme=even --baseUrl=\u0026quot;https://befovy.github.io/\u0026quot;\r  提交至 github 上一步命令中会在 public 文件夹下生成静态博客网站所需要的全部内容。 将 public 目录中的内容全部提交到第二步创建的github仓库就大功告成了。 👏\n  如果有兴趣和精力，还可以用 github 提供的 webhooks，自行配置服务器并利用 hooks 自动触发这些过程的执行，可实现博客的自动更新。\n 本文通过 mirror 和 hugo 生成，原始地址 https://github.com/befovy/blogback/issues/6\n ","id":5,"section":"posts","summary":"一直觉得 Issue 是个特别好用的记录工具，看到很多人也直接把 Issue 作为个人博客。 Issue 可以碎片化的记录一些东西，然后在进行整理，最终形成一篇不错的博客内容。","tags":null,"title":"使用 mirror 和 hugo 实现 github issue 的博客自动同步","uri":"https://blog.befovy.com/2019/06/issue_20190630_6/","year":"2019"}],"tags":[{"title":"Flutter","uri":"https://blog.befovy.com/tags/flutter/"},{"title":"golang","uri":"https://blog.befovy.com/tags/golang/"}]}